# 로봇 제작 주문 전 준비 사항 (소프트웨어)

이 문서는 실제 로봇(4륜 구동, Dynamixel XL430 모터, OpenCR 1.0 보드, 라즈베리파이, 라이다, 카메라)이 도착하기 전에 소프트웨어적으로 준비해야 할 핵심 사항들을 요약합니다.

## 1. 로봇 모델 정의 (URDF)

*   **파일**: `myCar/real_BMW_core.xacro` 및 이를 통해 생성된 `myCar/real_BMW_core.urdf`
*   **내용**: 로봇의 몸통, 바퀴, 센서(라이다, 카메라)의 실제 측정된 크기와 위치를 정확하게 반영합니다. 시뮬레이션 전용 태그는 모두 제거되었습니다.
*   **목적**: RViz에서 로봇 모델을 정확하게 시각화하고, `robot_state_publisher`가 로봇의 TF(변환)를 올바르게 계산하도록 합니다.
*   **상태**: 준비 완료.

## 2. 실제 로봇 구동을 위한 ROS2 Launch 파일

*   **파일**: `launch/real_robot.launch.py`
*   **내용**: Gazebo와 같은 시뮬레이션 관련 노드를 모두 제거하고, 실제 하드웨어 드라이버 노드(`real_driver_node`), `robot_state_publisher`, 그리고 라이다/카메라 드라이버를 실행하기 위한 구조를 갖추고 있습니다.
*   **목적**: 실제 로봇 하드웨어를 ROS2 환경에서 구동합니다.
*   **상태**: 준비 완료.

## 3. 실제 로봇 드라이버 노드 (C++ 템플릿)

*   **파일**: `src/real_driver_node.cpp`
*   **내용**: `EduDrive` 시스템을 기반으로 하는 ROS2 노드의 뼈대입니다. CAN 통신을 통해 모터 컨트롤러와 통신하고, 센서 데이터를 읽어와 ROS 토픽으로 발행하는 기본적인 구조를 갖추고 있습니다.
*   **목적**: 라즈베리파이와 OpenCR 보드 및 모터, 센서 간의 통신을 담당하고 로봇의 움직임을 제어합니다.
*   **상태**: **구조는 준비 완료. 핵심 로직 구현 필요.**
    *   **OpenCR 통신 방식 확인 및 구현**: OpenCR 보드가 CAN 통신을 통해 Dynamixel 모터를 제어하는 방식인지 확인하고, `CAN2DYNAMIXEL` 펌웨어 사용 여부 및 프로토콜 일치 여부를 확인해야 합니다. 필요시 `src/MotorController.cpp` 및 `src/can/canprotocol.h` 수정 또는 `real_driver_node.cpp` 내 시리얼 통신 로직 구현이 필요합니다.
    *   **4륜 독립 구동 역기구학/순기구학 완성**: `EduDrive::controlMotors` 및 `edu::Odometry` 내에서 로봇의 실제 기구학에 맞는 정확한 계산 로직을 구현해야 합니다.

## 4. 빌드 시스템 설정

*   **파일**: `real_CMakeLists.txt`
*   **내용**: `real_driver_node`와 그 의존성들을 올바르게 빌드하도록 설정되었습니다.
*   **목적**: `real_driver_node` 실행 파일을 생성합니다.
*   **상태**: 준비 완료.

## 5. CAN 통신 환경 설정 가이드

*   **파일**: `README.md` (현재 디렉토리 내)
*   **내용**: 라즈베리파이 5에서 Docker를 사용하여 CAN 통신을 설정하는 자세한 방법이 한국어로 정리되어 있습니다.
*   **목적**: 라즈베리파이 호스트 OS와 Docker 컨테이너 간의 CAN 통신 환경을 구축합니다.
*   **상태**: 준비 완료.

## 요약 및 다음 단계

실제 로봇이 도착하기 전에 소프트웨어의 **기본적인 구조와 틀은 모두 준비되었습니다.**

로봇이 도착하면, 다음의 **핵심 구현 및 설정 작업**에 집중해야 합니다.

1.  **OpenCR 1.0에 `CAN2DYNAMIXEL` 펌웨어 업로드 및 튜닝**: 이 펌웨어가 CAN 메시지를 Dynamixel 명령으로 정확히 변환하도록 설정해야 합니다.
2.  **`parameter/edu_drive_edu_bot.yaml` 파라미터 튜닝**: 로봇의 실제 `kinematics` 값, `canID`, `gearRatio`, `encoderRatio`, `rpmMax` 등을 정확하게 입력해야 합니다.
3.  **`real_driver_node.cpp`의 핵심 로직 완성**: OpenCR과의 실제 통신(CAN 프로토콜 일치 여부 확인 및 필요시 수정) 및 4륜 독립 구동을 위한 정확한 역/순기구학 계산을 구현해야 합니다.
4.  **라이다 및 카메라 드라이버 통합**: 해당 센서 제조사에서 제공하는 ROS2 드라이버를 설치하고 `real_robot.launch.py`에 추가합니다.

이러한 준비가 완료되면, 실제 로봇을 구동하고 센서 데이터를 받아보며 네비게이션 및 SLAM 개발을 시작할 수 있을 것입니다.
